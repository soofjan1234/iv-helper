# 持久化

Redis 快，是因为数据在 **内存** 里。内存一断电，数据不就全没了吗？怎么备份呢，把内存里的数据，安全地留到磁盘上

## RDB

某个时间点，把 Redis 内存里的所有数据，整体保存成一份快照

一次性写成一个 .rdb 文件，文件小，恢复快，读一次就行

## AOF（append only file）

把你“做过什么”一条条记下来

文件会越来越大，同一个 key 被反复修改，全记下来了，比读快照慢

write、fsync都是系统调用

## AOF 重写（Rewrite）

1. 由于 AOF 重写会进行大量的写入操作，为了避免对 Redis 正常处理命令请求造成影响，Redis 将 AOF 重写程序放到子进程里执行。
2. AOF 文件重写期间，Redis 还会维护一个 **AOF 重写缓冲区**，该缓冲区会在子进程创建新 AOF 文件期间，记录服务器执行的所有写命令。
3. 当子进程完成创建新 AOF 文件的工作之后，服务器会将重写缓冲区中的所有内容追加到新 AOF 文件的末尾，使得新的 AOF 文件保存的数据库状态与现有的数据库状态一致。
4. 最后，服务器用新的 AOF 文件替换旧的 AOF 文件，以此来完成 AOF 文件重写操作

## 混合持久化

AOF 重写的时候就直接把 RDB 的内容写到 AOF 文件开头

# 缓存三兄弟

## 缓存穿透

缓存和数据库都没有，大量的请求过来，数据库崩溃

1. 缓存无效 key
2. 接口限流
3. 布隆过滤器：我说它不存在，那它肯定不在；我说它存在，它可能在

## 缓存击穿

缓存过期了，又是热点请求

1. **永不过期**：设置热点数据永不过期
2. **提前预热**：在缓存失效前提前预热数据
3. **加锁**：使用分布式锁避免多个请求同时查询数据库

## 缓存雪崩

缓存**大面积瘫痪**

1. **针对 Redis 服务不可用的情况**：使用 Redis 集群，多级缓存
2. **针对大量缓存同时失效的情况**：设置随机失效时间、提前预热、分批设置过期

# 双写一致性

## 手动挡-Cache Aside（旁路缓存）

**广泛使用。**应用程序的写操作完全绕过了缓存，直接操作数据库：

1. 读数据时，先从缓存读，如果缓存没有，从数据库读，并将读取到的数据存到缓存。
2. 写数据时，先写入数据库，然后删除缓存

写操作则存在风险，数据库和缓存毕竟是两套系统，如果都需要进行修改，它们的先后顺序可能导致数据不一致

**1.先更新缓存，再更新数据库**

第一次先更新缓存，然后更新数据库失败，第二次读缓存读的是错误的值

**2.先更新数据库，再更新缓存**

A更新数据库，更新缓存时网络延迟

B更新数据库，更新缓存成功

此时A更新缓存成功，数据不一致

**3.先删缓存，后改数据库**

 你刚删，读请求就把旧数据又搬回缓存了。

**4.先改数据库，后删缓存**

可能有什么不一致？

1. 缓存刚好失效
2. 读请求A访问数据库读到旧值
3. 写请求B修改为新值 删除缓存
4. 读请求A把旧值写回缓存

写库通常比读库慢，概率极低，除非第二步删缓存失败

1. **消息队列重试**：把要删除的 Key 发到 MQ，删不掉就一直试。
2. **订阅 Binlog**：用 Canal 这种工具监控 MySQL 的变化，一旦发现数据库变了，由 Canal 负责去删 Redis，把业务代码解耦

## 自动挡-Through 系列

**Read Through（读穿）：** 缓存没中？缓存服务自己去库里查，查完填好再给业务。

**Write Through（写穿）：** 业务写缓存，缓存服务**同步**写到数据库。数据最安全

**Write Behind（写回）：** 业务只管写缓存，缓存服务**异步**、批量地往数据库同步