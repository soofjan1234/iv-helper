## 为什么要引入消息队列

- **解耦**：HTTP 接口只负责业务（发凭证、查设备），「写操作记录/审计日志」不阻塞接口，通过发一条消息交给下游异步处理。
- **异步落库**：设备开启/关闭穿透、客户端拉信息、刷新 accessID 等事件，我们发到 `record_topic`，消费者统一写库或做统计，接口响应更快。
- **削峰**：请求突增时，写记录不会拖慢主流程，消息先堆积在队列里，消费者按能力消化。

## 为什么使用 NSQ

- 当前场景是「设备事件/操作记录异步落库」，不需要 Kafka 级别的高吞吐和分布式日志存储。
- NSQ，一个去中心化的消息队列
- 部署简单（单二进制、无外部依赖）、延迟低、Go 原生支持好，和项目规模、吞吐需求匹配。

## 对比 Kafka、RabbitMQ、Redis Stream

**对比 Kafka**

- Kafka 是分布式日志系统，强项是高吞吐、持久化、多副本，适合大数据/日志采集场景。
- 我们只是「设备事件异步落库」，不需要分区、副本那套，引入 Kafka 太重、运维成本高。

**对比 RabbitMQ**

- RabbitMQ 功能丰富：交换机、路由键、死信队列、事务消息等，适合复杂业务消息路由。
- 我们只需要简单的 topic 投递 + 消费，用不上那些功能

**对比 Redis Stream**

- Redis Stream 更适合"同一个项目里顺手用一下、丢几条也没事"的场景，比如实时通知、临时事件流。
- 我们需要独立的消息队列、磁盘持久化、消费失败可重试，Redis Stream 在这些方面不如专用 MQ 稳。

**总结**：NSQ 部署简单、延迟低、Go 支持好，刚好匹配我们「轻量异步落库」的需求，不需要更重的方案。

## NSQ架构

1. nsqd：真正干活的。负责接收消息、排队、发送给客户端。一个集群里可以有成百上千个 nsqd。
2. nsqlookupd：管理 nsqd 的注册和发现。消费者通过 nsqlookupd 找到可用的 nsqd。
3. nsqadmin：管理后台

## NSQ的 Topic 与 Channel

Topic（广播）：消息进入 Topic 后，会全量复制一份给它下面所有的 Channel。
Channel（分发）：消息进入 Channel 后，会随机选一个连接在这个 Channel 上的消费者（负载均衡）。

使用场景：

1. 订单系统，当一个订单产生，发货系统、积分系统、大数据系统需要记录。
2. 双十一时，Channel 会自动把消息均匀地分给消费者。

## 重复消费（幂等性）

消费者拿到消息、处理完了，但还没来得及告诉 NSQ"我处理好了"（ACK），这时消费者挂了或网络断了。
NSQ 等了一会没收到 ACK，就认为"没处理成功"，把消息重新投递给另一个消费者（或同一个重启后的消费者）。

要实现同一操作执行多次，结果与执行一次相同

解决方法

1. 业务侧做幂等：比如写库前先查一下"这条记录是不是已经存在了"，存在就跳过。
2. 或者用唯一 ID + 去重表：每条消息带个唯一 ID，处理前先查去重表，处理过就不再处理。

## 消息丢失

什么情况会丢
生产端：消息发出去了，但 NSQ 还没落盘就挂了 → 丢了。
NSQ 侧：默认消息存内存，如果 nsqd 进程崩溃且没开持久化 → 丢了。
消费端：消费者拿到消息，还没处理完就挂了，且 NSQ 那边已经认为投递成功 → 丢了（不过 NSQ 有超时重投机制，这种情况较少）。

怎么减少丢失

1. 开启持久化：NSQ 支持把消息写到磁盘，但会牺牲一些性能。
2. 生产端确认：发消息后检查返回值，失败就重试。
3. 消费端先处理再 ACK：不要一拿到消息就 ACK，处理完再 ACK；处理失败就 Requeue 让 NSQ 重投。