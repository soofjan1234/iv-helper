# 内存类型

## 1. 栈

### 存储

局部变量、函数参数和返回值、defer/panic/recover状态、**小规模**的数组或切片（若未发生逃逸

### **特点**

- **自动分配/释放**：函数调用时压栈，返回时弹栈，无需 GC 介入。
- **速度快**：仅需移动栈指针（纳秒级操作）。
- **大小有限**：默认 2~8 MB（可通过 `runtime.Stack` 调整）。

## 2.堆内存

### **存储**

动态大小的数据；逃逸的变量；大对象

### **特点**

- **GC 管理**：由垃圾回收器自动回收（三色标记算法）。
- **分配成本高**：需系统调用（如 `mmap`），速度比栈慢。
- **显式触发**：使用 `new()` 或 `&` 取地址不一定会分配到堆（由逃逸分析决定）。

## **3.全局区**

### **存储**

包级变量；常量

### **特点**

- **生命周期**：整个程序运行期间存在。
- **线程安全**：全局变量可能被多个 goroutine 共享（需加锁）。

# 内存回收

自动化内存管理机制，用于回收程序中不再使用的内存资源

采取的是“非分代的、非移动的、并发的、三色的”标记清除垃圾回收算法

原理：
- 首先把所有的对象都放到白色的集合中
- 从根节点开始遍历对象，遍历到的白色对象从白色集合中放到灰色集合中
- 遍历灰色集合中的对象，把灰色对象引用的白色集合的对象放入到灰色集合中，同时把遍历过的灰色集合中的对象放到黑色的集合中
- 循环步骤3，知道灰色集合中没有对象
- 步骤4 结束后，白色集合中的对象就是不可达对象，也就是垃圾，进行回收

# 内存泄露

内存泄漏（Memory Leak）是指在程序运行过程中，已经分配的内存没有被正确释放，导致程序使用的内存不断增加，最终可能导致系统资源枯竭、程序性能下降甚至崩溃。

1. 未释放的内存：程序申请了内存，但没有在合适的时机释放，导致内存一直占用，直到程序退出。
2. 未关闭的资源：例如，打开的文件、数据库连接或网络连接等没有被关闭，导致这些资源一直占用内存。
3. 循环引用：特别是在使用垃圾回收机制的语言中，如果两个对象相互引用，且没有其他地方引用它们，即使它们不再需要，也可能无法被垃圾回收器回收，导致内存泄漏

# 内存逃逸

当一个变量的生命周期超出了栈的范围，导致它被分配到堆上，而不是栈上。
栈内存是由编译器自动管理的，而堆内存则由垃圾回收器（GC）管理，通常堆上的变量生命周期更长，但也会带来更多的内存管理开销

典型情况：

- **在方法内把局部变量指针返回**
    
    局部变量原本应该在栈中分配，在栈中回收。但是由于返回时被外部引用，因此其生命周期大于栈，则溢出。
    
- **发送指针或带有指针的值到 channel 中**
    
    在编译时，是没有办法知道哪个 goroutine 会在 channel 上接收数据。所以编译器没法知道变量什么时候才会被释放。
    
- **在一个切片上存储指针或带指针的值**
    
    一个典型的例子就是 []*string 。这会导致切片的内容逃逸。尽管其后面的数组可能是在栈上分配的，但其引用的值一定是在堆上。
    
- **slice 的背后数组被重新分配**
    
    因为 append 时可能会超出其容量( cap )。 slice 初始化的地方在编译时是可以知道的，它最开始会在栈上分配。如果切片背后的存储要基于运行时的数据进行扩充，就会在堆上分配。
    
- **在 interface 类型上调用方法**
    
    在 interface 类型上调用方法都是动态调度的。方法的真正实现只能在运行时知道。想像一个 io.Reader 类型的变量 r , 调用 r.Read(b) 会使得 r 的值和切片 b 的背后存储都逃逸掉，所以会在堆上分配。
    

## 为什么要关注内存逃逸

1. 优化内存使用：
    - 栈由编译器自动管理，分配和释放速度非常快
    - 堆内存由垃圾回收器管理，过程复杂，管理开销大
2. 减少内存泄漏风险：更好了解程序内存使用情况
3. 性能优化：某些性能要求高的场景中，内存逃逸可能成为性能瓶颈

# Go和C++访问空指针行为

## 1. c++未定义行为，GO可控运行时panic

C++ 将指针视为原始内存地址，访问非法地址时由操作系统介入，开发者无法捕获或恢复；

Go 在运行时检查指针解引用操作，若发现 `nil` 指针，主动抛出 `panic` 而非依赖操作系统。

## 2.go的panic和recover机制

1. panic：中断当前函数执行，逐层向上回溯调用栈，执行每个函数的 `defer` 语句。
2. recover：仅在 `defer` 函数中生效，用于捕获当前 goroutine 的 `panic`，恢复程序控制流。

## 3.**Go 实现安全性的关键设计**

1. **运行时检查**
2. **基于 goroutine 的隔离性**
3. **明确的错误处理哲学**
    1. Go 鼓励通过 **返回值显式处理错误**（而非异常机制），`panic` 仅用于不可恢复错误（如空指针）