# SDS

C 语言原生的字符串很笨：

1. 它不知道自己有多长，每次想知道长度都要从头数到尾
2. 不安全，如果你想往后面加点字，一不小心就会缓冲区溢出
3. 性能差，每次改字符串都要**手动申请/释放内存**
4. 无法存二进制数据，`\0` 直接截断

SDS 的核心改进：

```markdown
struct sdshdr {
    int len;    // 已用长度
    int alloc;  // 总容量
    char buf[];
}
```

聪明在：

1. 常数时间获取长度
2. SDS 依赖 `len` 字段而非 `\0` 判断字符串结束，拼接避免内存泄漏，同时二进制安全
3. 惰性空间释放：字符串缩短时不会立即回收内存，可供后续使用
4. 兼容 C 字符串函数

扩容：若新长度 < 1MB，加倍扩容；否则每次多分配 1MB（避免过度浪费）

# ZipList

Redis对待内存像对金钱一样，如果你只存几个小数字，也用双向链表（前后两个指针占 16 字节），太浪费了。于是有了 **Ziplist**，把数据像挤公交一样塞在一起

厉害在极致省内存，连续数组，还可以增加CPU缓存命中率。

但是为了能双向移动，强行让后一个节点记录前一个节点的长度（previous_entry_length）。

Redis 为了省钱，给这个位置设了两个档位：**1 字节**：如果前任长度< 254字节；否则是**5 字节**

如果中间一个人突然变胖（修改了一个很长的数据），后面的人都得跟着挪位置，这叫**连锁更新**

# ListPack

不再记录“前一个人的长度”，而是记录“我自己的长度”。

想往回跳？没问题，你先往回看一个字节，那是前一个节点的“结尾标志”，它会告诉你它自己有多长，你直接按它说的长度往回跳就行了

在 ListPack 里，更新操作只会触发一次内存拷贝（极快），绝对不会引发多米诺骨牌式的全员扩容。

# QuickList

怎么解决ZipList的问题？又想省内存，又需要存大数据。Redis 灵机一动：我把长长的列表切成一段一段的，每一段还是 Ziplist，然后用双向指针连起来，不就行了。

现在改为每一段是一个 ListPack。

# IntSet

如果你的 Set 集合里存的全是整数，那连 ZipList 都显得有点重了。Redis 专门搞了个 **IntSet**。

# HashTable

# SkipList

ZSet 需要排序。提到排序，大厂面试官爱问红黑树，但红黑树实现太复杂了。Redis 选了 **Skiplist（跳表）**：既然一层一层数太慢，我就搞个“快进键”，建几层索引。

Skiplist 就是一个带多层索引的有序链表，是一种空间换时间的思想，相比红黑树，它实现简单、范围查询更自然

## 增加

在红黑树里，增加节点要考虑旋转、变色，维持平衡。而跳表非常佛系：每当新插入一个节点，我就原地抛硬币。
1. 先插底层：首先，新节点一定会老老实实地插入到最底层的有序链表中。
2. 抛硬币决定“晋升”：
    ◦ 抛一次硬币，正面？恭喜，升到第二层，在第二层也建个索引指向它。
    ◦ 再抛一次，还是正面？继续升到第三层。
    ◦ 反面？停，到此为止。
3. 连接指针：在每一层，把左边节点的指针指向自己，把自己的指针指向右边。

**为什么这么做？**
如果不随机，为了保证每两点提拔一个索引，你每次插入都要重调整个结构。而随机概率保证了：从宏观上看，高层节点大约是低层的一半，依然能维持 $O(\log n)$ 的查找效率

# 对应关系

1. String对应SDS，List对应QuickList没问题
2. Set
    1. 假设全是整数，就直接IntSet
    2. 否则转为Hashtable
3. Hash
    1. 小的就是Listpack
    2. 否则转为Hashtable
4. ZSet
    1. 为什么开始不用IntSet？因为IntSet只能存整数，而ListPack能存[成员1][分数1]
    2. 既然跳表已经是有序的了，为什么要多浪费一份内存去搞个 Hashtable？
    3. 继续空间换时间，要O(1)查询
    4. 并没有存两份，字典和跳表里存的都只是指向这个对象的**指针**，只有指针的开销