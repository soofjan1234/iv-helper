## 1.1 Go

### 1.1.1 Go语言的优点

1. **天然支持高并发**
    
    Go语言通过goroutine和channel机制，提供了轻量级的并发支持。goroutine的创建和调度开销远小于线程，使得Go在处理高并发场景时表现出色。
    
2. **学习成本低，上手快**
    
    Go语言的语法简洁，去除了许多复杂的概念（如继承、泛型等），使得开发者可以快速上手并投入生产。
    
3. **性能高**
    
    Go语言编译后的二进制文件直接运行在操作系统上，无需虚拟机，执行效率高。同时，Go的垃圾回收机制经过优化，减少了GC带来的性能损耗。
    
4. **编译后二进制包体积小**
    
    Go语言编译后的二进制文件不依赖外部库，体积小，便于部署和分发。
    

### 1.1.2 Go和Java的区别

1. **语言性**: Go简单；Java语言较为复杂，包含更多特性
2. **类型系统**：
    - Go支持类型推断，
    - Go不支持继承，使用组合来实现代码复用，更加灵活，松耦合；Java支持继承和多态
3. **并发**：Go使用goroutines和channels实现并发；Java基于Thread和Runnable实现并发
4. **跨平台**：Go直接编译为机器码，性能高；Java需要JVM运行，性能相对较低
5. **垃圾回收** ：Go支持并发垃圾回收，使用并行标记-清除算法；Java使用多种垃圾回收器，如G1、CMS等

## 1.2 Go切片

### 1.2.1 切片和数组的区别？

1. **长度**：数组长度固定；长度可变，支持自动扩容
2. **声明方式不同** ：数组`var arr [5]int`；切片`var slice []int`
3. **内存分配** ：数组值类型；切片引用类型，底层引用数组
4. **传递开销**：数组传递时会复制整个数组；切片仅复制切片头（包含指针、长度和容量）

### 1.2.2 切片的关键特性、基本属性、注意点

1. **底层依赖数组**
    
    当切片基于数组创建时，它们会**共享同一块底层内存空间**。这意味着通过切片修改元素会直接影响原始数组，反之亦然。
    
2. **创建方式**
- 从数组创建：`slice := arr[start:end]`
- 直接创建：`slice := make([]int, length, capacity)`
1. **零值**
    
    切片的零值为`nil`，表示未初始化的切片。
    
2. **性能优化**
- 一次分配足够空间，避免频繁扩容
- 合理设置容量，减少内存分配次数

### 1.2.3 如何扩容

1. **触发条件**
    
    当切片的长度超过容量时，Go会自动触发扩容。
    
2. **扩容算法**
- 小切片(<256元素)：双倍扩容
- 大切片(≥256元素)：平滑过渡到约1.25倍扩容
1. **内存对齐、分片**
    
    Go在扩容时会考虑内存对齐，以提高访问效率。
    
2. **数据迁移**
    
    扩容后，原数据会被复制到新的内存空间。
    

### 1.2.3 遍历添加元素

for range循环不会被遍历到

## 1.4 Go其他

### 1.4.1 深度拷贝

1. **使用json序列化、反序列化**
    
    通过json序列化和反序列化实现深度拷贝，但性能较低。
    
2. **gob编码**
    
    使用gob编码进行深度拷贝，比json性能更好，可以处理更复杂的类型。
    
3. **第三方库**
    
    可以使用`github.com/jinzhu/copier`等第三方库实现深度拷贝。
    
4. **手动实现**
    
    对于简单的结构体，可以手动实现深度拷贝方法。
    

### 1.4.2 锁

1. 互斥锁mutex
2. 读写锁rwmutex
3. sync.map：靠原子操作和细粒度锁
4. 原子操作：严格来说这不算“锁”，利用 CPU 提供的特殊指令
5. waitGroup
WaitGroup 提供了三个基本操作：
Add：设置要等待的 goroutine 数量。
Done：通知 WaitGroup 一个任务已经完成。
Wait：阻塞直到所有的 goroutine 完成
6. channel

### 1.4.4 闭包

闭包 = 一个函数 + 它引用的外部变量的环境

```
func createCounter() func() int {
    count := 0 // 这个变量被“拎”走了

    // 返回一个匿名函数（闭包）
    return func() int {
        count++ // 引用了外部的 count
        return count
    }
}

```

1. 特性：
    - 函数可以访问并且共享外部变量
    - 即使在函数外，变量也不会被 GC
2. 用途：
    - 数据封装/私有化：有点像面向对象里的“私有成员变量”
    - **生成器/工厂模式**：可以根据参数生成具有不同行为的函数
    - 回调与延迟执行：经常用闭包来“捕捉”当前的上下文状态，等以后某个时刻（比如请求返回时）再运行。
3. 和函数的区别：
    - 普通函数能访问参数+全局变量；闭包还能访问捕获的外部变量
    - 普通函数执行完后，参数和局部变量会被释放；闭包的外部变量会一直存在
    - 闭包内存占用更大些
    - 闭包非并发安全