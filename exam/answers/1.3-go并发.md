# 一、Go Channel

```markdown
ch := make(chan int) // 创建 channel（无缓冲）
ch <- 1              // 发送
x := <-ch            // 接收
close(ch)            // 关闭
```

channel 是 goroutine 协程之间“安全地传值 + 同步”的工具

## 1. 什么时候会被用到

1. 数据传递。两个协程之间传数据
2. 事件通知。等任务完成
3. 生产者 / 消费者。和第一点的不同在于：是持续的，不是一次；生产、消费速度可能不一样
4. 限制并发数。
    
    ```markdown
    sem := make(chan struct{}, 3)
    
    for i := 0; i < 10; i++ {
        sem <- struct{}{} // acquire
        go func(i int) {
            defer func() { <-sem }() // release
            fmt.Println(i)
            time.Sleep(time.Second)
        }(i)
    }
    ```
    
5. 多路复用与超时控制
    
    ```markdown
    ticker := time.NewTicker(time.Second)
    defer ticker.Stop()
    
    for {
        select {
        case <-ticker.C:
            fmt.Println("tick")
        case <-quit:
            return
        }
    }
    ```
    
6. 任务取消。本质是关闭一个广播 channel

## 2.问题

### 1. 对未初始化的的chan进行读写，会怎么样

读写未初始化的chan都会阻塞。

### 2. 如何判断一个channel已经关闭

1. **`value, ok := <-ch`：**通过 `ok` 判断 channel 是否关闭
2. **`for range` 遍历 `channel：`**当 channel 关闭时循环结束

### 3. 往一个已经关闭的channel写、读数据会怎么样？

1. **写数据：**立即 panic
2. **读数据：**有数据正常读取；无数据返回零值
3. **关闭已关闭的也会panic**

# 二、调度模型

## 1. 为什么协程 goroutine比较轻量

1. **快速创建/销毁**
2. **内存占用极低：**初始栈大小仅 2KB（对比线程通常 1-8MB 并且是静态分配），动态增长收缩
3. **用户态调度（零内核开销）**：线程的创建和切换都需要进入内核
4. **GMP调度效率优化**
5. **数量优势：**操作系统通常可以处理的线程数量在数百到几千个之间；Go 运行时可以轻松地创建和管理成千上万的协程

## 2. GM模型

goroutine（G） 和线程（M）的映射关系。Go 最初采用 N:M 的映射方式

**全局锁带来的锁竞争、M 会频繁交接 G，性能下降**

## 3. GMP

将 Goroutines 分配到 M 上执行，而 P 是调度的核心。多个 P 可以共享一个或多个 M。

1. **G (Goroutine)：**每个协程，包含了一个执行上下文（如栈、指令指针等）和一个调度状态
2. **M (Machine)：**一个操作系统线程
3. **P (Processor)：**负责管理运行时的调度队列，决定哪些 G 应该被执行

## 4. 调度系统的目标

在有限的 OS 线程上，高效、公平地运行大量 goroutine

**什么时候会发生 Goroutine 切换？**

1. 主动让出
2. 系统调用阻塞
3. 时间片用完
4. 通道、锁操作

**下一个 Goroutine 从哪来？**

1. P 的本地队列（256）
2. 全局队列：本地队列空，工作窃取失败，新建 G 被标记为 global
3. 工作窃取
    1. 当一个 P 空闲，另一个 P 很忙
    2. 从其他 P 的 本地队列尾部窃取 一半（至少 1 个）G

**有 P，但暂时没 G，怎么办？**

M 进入自旋态，快速轮询是否有新 G，避免频繁 sleep / wake

**阻塞后上阻塞谁？阻塞结束后会干嘛**

 IO阻塞

1. 阻塞G，M被释放执行其他G
2. G尝试重新进入调度队列，调度器找一个可用的M来执行G

系统调用

1. 短时间：M阻塞，P仍然绑定M
2. 长时间：M解绑P，交给其他M