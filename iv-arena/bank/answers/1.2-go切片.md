## 初始化

1. 通过下标的方式获得数组或者切片的一部分；
    1. 最原始也最接近汇编语言的方式
    2. 如果是切片的一部分，那么指向的是同一个地方
2. 使用字面量初始化新的切片；
    1. 编译期间会在静态区创建数组，创建数组指针，赋值
    2. 通过[:]获取切片
3. 使用关键字 `make` 创建切片：
    1. 需要运行时的参与
    2. 必须传大小，可选容量
    3. 小的在栈，大的或发生逃逸的在堆

```jsx
arr[0:3] or slice[0:3]
slice := []int{1, 2, 3}
slice := make([]int, 10)
```

## 扩容

在较新版本的 Go（1.18+）中，扩容策略已经不再是简单的“1024 字节以下翻倍，以上 1.25 倍”。而是：

1. 切片新长度大于当前容量的两倍，会使用新长度
2. 如果旧容量小于 256，则新容量翻倍。
3. 否则平滑过渡到1.25倍逐渐扩容，直到大于等于新长度

然而这只是大致容量，下面还需进行内存对齐，为什么？

1. **内存管理器的限制**： Go 的内存管理器并不是你想要多少字节就正好给你分配多少。为了减少内存碎片，它预先定义了一系列**标准内存块大小**，比如 8, 16, 32, 48 ... 32768 字节等。
2. **避免浪费**： 如果你计算出来扩容后需要 40 字节，但内存管理器最小只能给你 48 字节的块。与其白白浪费那 8 字节，不如**直接把切片的容量（cap）提升到 48 字节所能容纳的数量**。

最后收尾工作：看看有没有溢出；申请新内存；数据迁移。

# 三、切片和数组的区别？

1. **长度**：数组长度固定；长度可变，支持自动扩容
2. **声明方式不同**
3. **内存分配** ：数组值类型；切片引用类型，底层引用数组
4. **传递开销**：数组传递时会复制整个数组；切片仅复制指针、长度和容量